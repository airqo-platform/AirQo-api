app:
  name: airqo-device-registry-api
  label: device-reg-api
  namespace: production
  configmap: env-device-registry-production

#  Set to match minReplicas (HPA will manage this)
replicaCount: 3 # Matches minReplicas - HPA controls actual count

image:
  repository: eu.gcr.io/airqo-250220/airqo-device-registry-api
  tag: prod-8f262e7d-1761041486

nameOverride: ""
fullnameOverride: ""

podAnnotations: {}

resources:
  limits:
    cpu: 2000m # 10x increase from 200m
    memory: 2Gi # Increased for safety
  requests:
    cpu: 500m # 50x increase from 10m
    memory: 1Gi # Realistic baseline

# Health checks added
readinessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 3

livenessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 3

#  Reduced startup time from 150s to 60s
startupProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 0
  periodSeconds: 5
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 12 # 60 seconds total (12 Ã— 5s) - increase if app startup is genuinely slow

#  Keep sleep for now (works without code changes)
# TODO: Replace with active shutdown endpoint when /shutdown is implemented
lifecycle:
  preStop:
    exec:
      command: ["/bin/sh", "-c", "sleep 15"]
  # Alternative (requires app code changes):
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "curl -X POST http://localhost:3000/shutdown || sleep 15"]

terminationGracePeriodSeconds: 30

nodeSelector:
  role: moderate-usage

affinity:
  nodeAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - preference:
          matchExpressions:
            - key: role
              operator: In
              values:
                - moderate-usage
        weight: 1
  # Spread pods across nodes
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - device-reg-api
          topologyKey: kubernetes.io/hostname

priorityClassName: high-priority

volumeMounts:
  - name: config-volume
    mountPath: /etc/config
  # Add writable tmp for read-only filesystem
  - name: tmp-volume
    mountPath: /tmp
  - name: cache-volume
    mountPath: /app/.npm # Node.js npm cache

volumes:
  - name: config-volume
    configMap:
      name: device-registry-config-files
  # Writable volumes for read-only filesystem
  - name: tmp-volume
    emptyDir: {}
  - name: cache-volume
    emptyDir: {}

ingress:
  enabled: false

service:
  type: NodePort
  port: 3000
  protocol: TCP
  targetPort: 3000
  nodePort: 30002

autoscaling:
  enabled: true
  minReplicas: 3 # Minimum 3 pods always
  maxReplicas: 10 # Scale up to 10 during high load
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80

#  Changed from minAvailable to maxUnavailable
podDisruptionBudget:
  enabled: true
  maxUnavailable: 1 # Allow one pod disruption at a time (works with minReplicas: 3)

# Enable read-only filesystem with writable volumes
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true #  Security best practice
  allowPrivilegeEscalation: false #  Additional security

#  Container security context
containerSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
